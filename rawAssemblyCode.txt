save #41	// Get P from memory location 41
store $r7 // r7 = 41 now
lb $r7    // lb : $acc = M[$reg]
store $r7
save #42	// Get tap pattern
store $r1
lb $r1
store $r1
save #43	// Get seed from memory location 43
store $r0
lb $r0		// store seed in r0 and r3
store $r3
store $r0
save #0        	// counter
store $r5
save #64	//the counter to keep track memory location writing to
store $r6
save #40
add $r7
store $r8          // r8 = r7 + 40
loop1:	// start
save encode_space
store dst
put $r5
gtr $r8  //r5>r8?
btr     //if so jump to encode_space
save encode_char
store dst
put $r5
gtr $r7 // r5 > r7?
btr      // if so jump to encode_char
encode_space:
save #32
xor $r0
sb $r6     //takes a space and xor it with r0, then write back to memory
jmp continue
encode_char:
//read a value from memory and xor it with r0, then write back to memory
put $r5
xor $r0
sb $r6
jmp continue
continue:
put $r1		// pass only the 4 tap values
and $r0
store $r2
save #1	// left-shift pattern
store $r4
put $r0
srl $r4
store $r0
xor r2, r2, lsr #4	// find the parity in 3 steps
xor r2, r2, lsr #2
xor r2, r2, lsr #1
save #1          	// want just the parity bit (LSB)
store $t1
put $r2
and $t1
store $r2
put $r0		// bring in parity to LSB
add $r2
store $r0
save 255	// keep just the lower 8 bits
and $r0
store $r0
save #1	// increment counters of r5 and r6
add $r5
store $r5
save #1
add $r6
store $r6
save done	//done if r6 reach 127
store dst
save #126
sub $r6
btr
jmp loop1
done:

save #64
store $r0  //put 64 into r0
lb $r0     //get the value from memory[64] on accumulator
store $r1  //put mem[64] into r1
save #32   //
xor $r1    //xor it with 32 to get the first state(seed), get the seed on accumulator
store $r3  //store the seed into r3 and r0
store $r0
save #128
store $r4
lb $r4
store r1 //tap pattern
save #0        	     // counter
lb r5
save #64             // mem counter
lb r6
save #1              // exit code
store r7
try_pattern:
put r1
and r0             // pass only the 4 tap values
store r2
check_space:
//takes a space and xor it with r0
save #32
xor r0
//compare it with what is in mem[64]
cmp r6
//if match, continue
btr continue
//if not, set r7 = 0(not the pattern we want)
save #0
store r7		//give exit code 0 if not true
jmp done2
continue:
save #1
store r4
put r0
srl r4
store r0           	// left-shift pattern
xor r2, r2, lsr #4 	// find the parity in 3 steps
xor r2, r2, lsr #2
xor r2, r2, lsr #1
save #1          	// want just the parity bit (LSB)
store t1
put r2
and t1
store r2
put r0		// bring in parity to LSB
add r2
store r0
save 255	// keep just the lower 8 bits
and r0
store r0
save #1	// increment counters of r5 and r6
add r5
store r5
save #1	// increment counters of r6
add r6
store r6
save #8	// done if r5 reach 8
cmp r5
btr done2:
done2:
save #1
cmp $r7
btr done_find_tap_and_seed
save #1
add $r4
store $r4
jmp try_pattern
done_find_tap_and_seed:
put $r4
store $r1
put $r3
store $r0
save #0
store $r5
store $r6
store $r8
save #64
store $r7
decipher:
save #1
cmp $r8
btr decoding
lb $r7
xor $r0
store $r9
save #32
cmp $r9
btr run_lfsr
save #1
store $r8
jmp decoding
decoding:
lb $r7
xor $r0
sb $r6
save #1
add $r6
store $r6
jmp run_lfsr
run_lfsr:
put $r1
and $r0
store $r2
save #1	// left-shift pattern
store $r4
put $r0
srl $r4
store $r0
xor r2, r2, lsr #4	// find the parity in 3 steps
xor r2, r2, lsr #2
xor r2, r2, lsr #1
save #1          	// want just the parity bit (LSB)
store $t1
put $r2
and $t1
store $r2
put $r0		// bring in parity to LSB
add $r2
store $r0
save 255	// keep just the lower 8 bits
and $r0
store $r0
save #1
add $r7
store $r7
save #127
cmp $r7
btr done3
jmp decipher
done3:
