9. Program: encrypter
// r9 = working register (variable), the thing we need for every iteration(states for LFSR)
// r1 = tap pattern (fixed for a given message)
//   	  legitimate (hex) values are: e1, d4, c6, b8,
//                                     b4, b2, fa, f3
// r2 = parity computation (variable)
// r3 = seed (fixed by first line of program)
// r5 = state counter -- should hit 2**N-1 for N taps, used to indicate the location to read, initially 0
// r6 = indicate the index of memory space to write to, start from 64
// r7 = p, the number of spaces need to append before the message
// r8 = p + 40
// r10 is used as tempory register
save #41	// Get P from memory location 41
store $r7 // r7 = 41 now
lb $r7    // lb : $acc = M[$reg]
store $r7 // r7 = P now

save #42	// Get tap pattern
store $r1
lb $r1
store $r1 // r1 = tap pattern now

save #43	// Get seed from memory location 43
store $r9
lb $r9
store $r3
store $r9 // store seed in r0 and r3


save #0        	// set counter r5 to 0
store $r5

save #64	//set counter r6 to 64
store $r6

save #40
add $r7
store $r8          // r8 = r7 + 40
//end of values initiallization



//Every loop encode one character, this loop run 64 times to encode all characters to 64-127
loop1:	// start
//First, check if r5 > r8, if so perform encode_space
save encode_space
store $dst
put $r5
gtr $r8  //r5>r8?
btr     //if so jump to encode_space

//Then,check if r5> r7, if so perform encode_char
save encode_char
store $dst
put $r5
gtr $r7 // r5 > r7?
btr      // if so jump to encode_char

//If none of above is the case, perform encode_space
//encode_space: takes a space and xor it with r1, then write back to memory at memory 64-127
encode_space:
save #32
xor $r9
sb $r6     //takes a space and xor it with r0, then write back to memory
save lfsr
store $dst
jmp

encode_char:
//read a value from memory and xor it with r0, then write back to memory
put $r5
xor $r9
sb $r6
save lfsr
store $dst
jmp


// end, the code above finish the writting to memory, following code are the engine of LFSR and update the r0
lfsr:

put $r1		// pass only the 4 tap values
and $r9
store $r2

save #1	// left-shift pattern
store $r4
put $r9
sfl $r4
store $r9

// find the parity in 3 steps
save #4
store $r10
put $r2
xor $r2
sfl $r10
store $r2

save #2
store $r10
put $r2
xor $r2
sfl $r10
store $r2

save #1
store $r10
put $r2
xor $r2
sfl $r10
store $r2

save #1          	// want just the parity bit (LSB)
store $r10
put $r2
and $r10
store $r2

put $r9		// bring in parity to LSB
add $r2
store $r9

save #255	// keep just the lower 8 bits
and $r9
store $r9
//End of LFSR engine, by here, we finish updating r0



//Following code are to update pointers of r5 and r6
save #1	// increment counters of r5 and r6
add $r5
store $r5

save #1
add $r6
store $r6

save done	//done if r6 reach 127
store $dst
save #126
sub $r6            //if r6 = 127, this subtraction will give us 1, which can be feed to btr
btr
save loop1
store $dst
jmp
done:
