

//If this line is reached, it means we successfully find the pattern, which is stored in $r4
//and we also have seed at $r3, ready to do some decrypting!


// r9 = working register (variable), the thing we need for every iteration(states for LFSR)
// r1 = tap pattern (fixed for a given message)
//   	  legitimate (hex) values are: e1, d4, c6, b8,
//                                     b4, b2, fa, f3
// r2 = parity computation (variable)
// r3 = seed (fixed by first line of program)
// r5 = state counter -- should hit 2**N-1 for N taps, used to indicate the location to read, initially 0
// r6 = indicate the index of memory space to write to, start from 0
// r7 = state counter for where to read, start from 64
// r8 = indicate whether begin to write to, initially 0
//initialize r9,r1,r3,r5,r6,r7
put $r4
store $r1
put $r3
store $r9
save #0
store $r5
store $r6
store $r8
save #64
store $r7
// end of initiallization


decipher:
//start of reading and writting
//see if r8 is set(begin to write to memory), if so perform decode a char
save #1
cmp $r8
btr decoding
//else decipher a char and see if it is space, if so jump to run_lfsr, else perform decode a char
lb $r7
xor $r9
store $r11
// see if it is space
save #32
cmp $r11
btr run_lfsr
save #1
store $r8
jmp decoding

decoding:
//decipher a char and put it at MEM[r6], then increment r6
lb $r7
xor $r9
sb $r6

save #1
add $r6
store $r6
jmp run_lfsr


//start of lfsr engine
run_lfsr:
put $r1		// pass only the 4 tap values
and $r9
store $r2

save #1	// left-shift pattern
store $r4
put $r9
srl $r4
store $r9

xor r2, r2, lsr #4	// find the parity in 3 steps
xor r2, r2, lsr #2
xor r2, r2, lsr #1

save #1          	// want just the parity bit (LSB)
store $t1
put $r2
and $t1
store $r2

put $r9		// bring in parity to LSB
add $r2
store $r9

save 255	// keep just the lower 8 bits
and $r9
store $r9
//end of lfsr engine

//increment r7 by 1, if r7 reach 127, break and exist
save #1
add $r7
store $r7

save #127
cmp $r7
btr done3
jmp decipher
